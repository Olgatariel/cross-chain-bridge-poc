// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SubscriptionService is ReentrancyGuard, Ownable {
    struct Subscription {
        address user;
        uint timeStart;
        uint timeEnd;
        bool status;
    }

    mapping(address => Subscription[]) public subscriptions;
    uint public price;

    constructor(uint _initialPrice) {
        price = _initialPrice;
    }

    error InvalidPaymentAmount();
    error NoSubscriptionToRenew();
    error HasSubscription();
    error InvalidPrice();
    error SamePrice();

    event Subscribed(address user, uint timeStart, uint timeEnd);
    event PriceChanged(uint oldPrice, uint newPrice);

    function subscribe() public payable nonReentrant {
        if (msg.value != price) revert InvalidPaymentAmount();
        Subscription memory newSubscript = Subscription({
            user: msg.sender,
            timeStart: block.timestamp,
            timeEnd: block.timestamp + 30 days,
            status: true
        });
        subscriptions[msg.sender].push(newSubscript);
        emit Subscribed(msg.sender, block.timestamp, block.timestamp + 30 days);
    }

    function isActive(address user) public view returns (bool) {
        if (subscriptions[user].length == 0) {
            return false;
        }
        Subscription memory lastSub = subscriptions[user][
            subscriptions[user].length - 1
        ];

        if (block.timestamp > lastSub.timeEnd) return false;
        if (lastSub.status != true) return false;
        return true;
    }
    function renew() public payable nonReentrant {
        if (msg.value != price) revert InvalidPaymentAmount();
        if (subscriptions[msg.sender].length == 0)
            revert NoSubscriptionToRenew();

        Subscription memory lastSub = subscriptions[msg.sender][
            subscriptions[msg.sender].length - 1
        ];

        if (lastSub.timeEnd > block.timestamp) revert HasSubscription();
        subscriptions[msg.sender][subscriptions[msg.sender].length - 1]
            .status = false;
        Subscription memory newSubscript = Subscription({
            user: msg.sender,
            timeStart: block.timestamp,
            timeEnd: block.timestamp + 30 days,
            status: true
        });
        subscriptions[msg.sender].push(newSubscript);
        emit Subscribed(msg.sender, block.timestamp, block.timestamp + 30 days);
    }
    function changePrice(uint _newPrice) public onlyOwner {
        if (_newPrice <= 0) revert InvalidPrice();
        if (_newPrice == price) revert SamePrice();
        uint oldPrice = price;
        price = _newPrice;
        emit PriceChanged(oldPrice, _newPrice);
    }
}
