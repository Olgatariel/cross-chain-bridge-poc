// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract studyVesting is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;
    using Address for address payable;

    //errors
    error InvalidAddress();
    error AlredyActive();
    error InvalidDuration();
    error InsufficientTokens();
    error CliffStillLocked();
    error VestingNotActive();
    error NothingToClaim();

    //events
    event TokensClaimed(address indexed beneficiary, uint256 amount);
   

   //state variables
    IERC20 public immutable token;
    uint256 totalVested;
    

    struct VestingSchedule {
        uint256 totalAmount;         //скільки всього у юзера токенів
        uint256 amountClaimed;       //скільки вже отримав юзер
        uint256 startTime;           //час початку вестингу
        uint256 cliffDuration;       //тривалість кліффу
        uint256 vestingDuration;     //загальна тривалість вестингу
        bool active;
    }

    mapping(address => VestingSchedule) public vestingSchedules;
    //constructor
    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }   
    //functions
    function createVestingSchedule(
        address beneficiary,
        uint256 startTime,
        uint256 totalAmount,
        uint256 cliffDuration,
        uint256 vestingDuration) external onlyOwner whenNotPaused {
            if(beneficiary == address(0)) revert InvalidAddress();
            if(vestingSchedules[beneficiary].active) revert AlreadyActive();
            if(vestingDuration <= cliffDuration) revert InvalidDuration();
            if(token.balanceOf(address(this)) < totalVested + totalAmount) revert InsufficientTokens();
            vestingSchedules[benificiary] = VestingSchedule({
                totalAmount: totalAmount,
                amountClaimed: 0,
                startTime: startTime,
                cliffDuration: cliffDuration,
                vestingDuration: vestingDuration,
                active: true
            });
            totalVested += totalAmount;
    }
    function claimTokens() external whenNotPaused nonReentrant {
    VestingSchedule storage client = vestingSchedules[msg.sender];
    
    if(!client.active) revert VestingNotActive();
    if(block.timestamp < client.startTime + client.cliffDuration) revert CliffStillLocked();
    
    uint256 claimable;
    
    // Якщо весь vesting період закінчився
    if(block.timestamp >= client.startTime + client.cliffDuration + client.vestingDuration) {
        claimable = client.totalAmount - client.amountClaimed;
    } 
    // Якщо ми всередині vesting періоду
    else {
        uint256 elapsed = block.timestamp - (client.startTime + client.cliffDuration);
        uint256 percentage = (elapsed * 1e18) / client.vestingDuration;
        uint256 totalAvailable = (client.totalAmount * percentage) / 1e18;
        claimable = totalAvailable - client.amountClaimed;
    }
    
    if(claimable == 0) revert NothingToClaim();
    
    client.amountClaimed += claimable;
    token.safeTransfer(msg.sender, claimable);
    
    emit TokensClaimed(msg.sender, claimable);
}

        }
        


    }  IERC20(TOKEN).safeTransfer(msg.sender, tokenForSend);
       



