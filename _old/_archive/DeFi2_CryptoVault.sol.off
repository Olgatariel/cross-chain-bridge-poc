// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Timers.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SimpleStaking is ReentrancyGuard, Ownable {
    //Події
    event Staked(
        address indexed user,
        uint256 id,
        uint256 amount,
        uint256 timestamp
    );
    event Unstaked(address indexed user, uint256 id, uint256 amount);

    //помилки

    error InvalidAmount();
    error NotAllowed();
    error TimeNotFinished();

    //Константи та глобальні змінні
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant TREASURER_ROLE = keccak256("TREASURER_ROLE");

    uint256 private minDeposit = 5;
    uint256 private minDuration = 30 days;
    uint256 private apr = 15;

    //лічильники, структури, мепінг
    using Timers for Timers.Timestamp;
    using SafeERC20 for IERC20;
    using Counters for Counters.Counter;
    Counters.Counter private stakeId;

    IERC20 public immutable token;
    constructor(address _token) {
        token = IERC20(_token);
    }

    struct StakeInfo {
        uint256 id;
        address user;
        uint256 amount;
        uint256 startTime;
        bool active;
    }

    mapping(address => uint256[]) public userToStakeIds;
    mapping(uint256 => StakeInfo) public stakes;

    function stake(uint256 _amount) external nonReentrant {
        if (_amount < minDeposit) revert InvalidAmount();

        uint256 allowed = token.allowance(msg.sender, address(this));
        if (allowed < _amount) revert NotAllowed();

        token.safeTransferFrom(msg.sender, address(this), _amount);

        stakeId.increment();
        uint256 currentId = stakeId.current();

        stakes[currentId] = StakeInfo({
            id: currentId,
            user: msg.sender,
            amount: _amount,
            startTime: block.timestamp,
            active: true
        });
        userToStakeIds[msg.sender].push(currentId);

        emit Staked(msg.sender, currentId, _amount, block.timestamp);
    }

    function _calculateReward(
        StakeInfo storage s
    ) internal view returns (uint256) {
        uint256 duration = block.timestamp - s.startTime;
        if (duration < minDuration) {
            return 0; // ще не пройшов мінімальний час — нагорода не нараховується
        }
        uint256 reward = (s.amount * apr * duration) / (100 * 365 days);
        return reward;
    }

    function unstake(uint256 _stakeId) external nonReentrant {
        StakeInfo storage s = stakes[_stakeId];

        if (s.user != msg.sender) revert NotAllowed();
        if (!s.active) revert InvalidAmount();

        uint256 reward = _calculateReward(s);
        if (reward == 0) revert TimeNotFinished();

        uint256 totalAmount = s.amount + reward;

        s.active = false;

        token.safeTransfer(msg.sender, totalAmount);

        emit Unstaked(msg.sender, _stakeId, totalAmount);
    }
    function getPendingReward(
        uint256 _stakeId
    ) external view returns (uint256) {
        StakeInfo storage s = stakes[_stakeId];
        if (s.user != msg.sender) revert NotAllowed();
        return _calculateReward(s);
    }
}
