// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;


import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract Crowdsale is Ownable, ReentrancyGuard, Pausable {
    using Address for address payable;
    using SafeERC20 for IERC20;

    //errors
    error InvalidAmount();
    error ZeroAddress();
    error TooLarge();
    error TooSmall();
    error NoPermission();
    error InvalidAddress();
    error HardCapExceeded();
    error InsufficientTokenBalance();


    //events
    event TokensPurchased(address indexed buyer,uint256 amountETH,uint256 amountTokens);


    //state variables
    address public immutable TOKEN;
    address public immutable TREASURY;
    uint256 public constant RATE = 1000;
    uint256 public constant MAX_HARD_CAP = 1000 ether;
    uint256 public constant MAX_INDIVIDUAL_CAP = 100 ether;
    uint256 public hardCap;
    uint256 public individualCap;
    uint256 public totalRaised;


    mapping (address => bool) public whitelist;
    mapping(address => uint256) public contributions;

    //constructor
    constructor (
        address _token, 
        address _treasury, 
        uint256 _hardCap,
        uint256 _individualCap
        )Ownable(msg.sender) {
            if(_token ==address(0) || _treasury == address(0)) {
                revert ZeroAddress();
            }

            if(_individualCap == 0|| _hardCap == 0) revert InvalidAmount();

            if(_individualCap > MAX_INDIVIDUAL_CAP)revert TooLarge();
            if (_individualCap > _hardCap) {
            revert TooLarge();
            }
            if(_hardCap < 1 ether) revert TooSmall();
            if(_hardCap > MAX_HARD_CAP) revert TooLarge();
            }
            TOKEN = _token;
            TREASURY = _treasury;
            hardCap = _hardCap;
            individualCap = _individualCap;            
        }

    function buyTokens()external payable whenNotPaused nonReentrant {
        if(msg.value == 0) revert InvalidAmount();
        if(!whitelist[msg.sender]) revert NoPermission();
        if(totalRaised + msg.value >= hardCap) revert HardCapExceeded();
        if(msg.value > individualCap) revert InvalidAmount();
        uint256 tokensTosend = msg.value * RATE;

        uint256 contractBalance = IERC20(TOKEN).balanceOf(address(this));
        if(contractBalance < tokensTosend){
            revert InsufficientTokenBalance();
        }
        
        totalRaised += msg.value;
        contributions[msg.sender] += msg.value;
        IERC20(TOKEN).safeTransfer(msg.sender, tokensTosend);
        emit TokensPurchased(msg.sender, msg.value, tokensTosend);

    }




 




}