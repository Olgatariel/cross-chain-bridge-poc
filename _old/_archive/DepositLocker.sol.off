// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract DepositLocker is Ownable, ReentrancyGuard, Pausable {
    struct Deposit {
        address user;
        uint amount;
        uint unlockTime;
        bool withdrawn;
    }
    mapping(address => Deposit[]) public deposits;

    error InvalidValue();
    error InvalidLockTime();
    error TimeIsLocked();
    error AlreadyWithdrawn();

    event Deposited(address indexed user, uint amount, uint unlockTime);
    event Withdrawn(address indexed user, uint amount);
    event Refunded(address indexed user, uint amount);

    function deposit(uint _lockPeriod) external payable nonReentrant {
        uint unlockTime = block.timestamp + _lockPeriod;
        if (msg.value == 0) revert InvalidValue();
        if (_lockPeriod == 0) revert InvalidLockTime();
        Deposit memory newDeposit = Deposit({
            user: msg.sender,
            amount: msg.value,
            unlockTime: unlockTime,
            withdrawn: false
        });

        deposits[msg.sender].push(newDeposit);
        emit Deposited(msg.sender, msg.value, unlockTime);
    }
    function withdraw(uint _index) external nonReentrant {
        Deposit storage userDeposit = deposits[msg.sender][_index];
        if (block.timestamp <= userDeposit.unlockTime) revert TimeIsLocked();
        if (userDeposit.withdrawn == true) revert AlreadyWithdrawn();
        userDeposit.withdrawn = true;
        (bool sent, ) = msg.sender.call{value: userDeposit.amount}("");
        require(sent, "Failed to send deposit");

        emit Withdrawn(msg.sender, userDeposit.amount);
    }
    function refund(
        address _user,
        uint _index
    ) external onlyOwner nonReentrant whenNotPaused {
        Deposit storage userDeposit = deposits[_user][_index];
        if (userDeposit.withdrawn == true) revert AlreadyWithdrawn();
        if (block.timestamp <= userDeposit.unlockTime) revert TimeIsLocked();
        userDeposit.withdrawn = true;
        (bool sent, ) = _user.call{value: userDeposit.amount}("");
        require(sent, "Failed to send deposit");

        emit Refunded(_user, userDeposit.amount);
    }
    function pause() external onlyOwner {
        _pause();
    }
    function unpause() external onlyOwner {
        _unpause();
    }

    function getDepositsCount(address _user) external view returns (uint) {
        return deposits[_user].length;
    }
    function getDeposit(
        address _user,
        uint _index
    ) external view returns (address, uint, uint, bool) {
        Deposit storage userDep = deposits[_user][_index];
        return (
            userDep.user,
            userDep.amount,
            userDep.unlockTime,
            userDep.withdrawn
        );
    }
}
