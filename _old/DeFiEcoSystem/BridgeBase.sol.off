// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract BridgeBase is Ownable, ReentrancyGuard {
    
    // Errors
    error ZeroAmount();
    error ZeroAddress();
    error TransferFailed();
    error InvalidNonce();
    error InsufficientLockedBalance(); 
    
    // Events
    event TokensLocked(
        address indexed user,
        uint256 amount,
        uint256 indexed nonce,
        bytes32 indexed messageHash
    );
    
    event TokensUnlocked(
        address indexed user,
        uint256 amount,
        uint256 indexed nonce
    );
    
    // State variables
    IERC20 public immutable token;
    uint256 public nonce;
    
    mapping(address => uint256) public lockedBalances;
    mapping(uint256 => bool) public processedUnlocks;
    
    constructor(address tokenAddress) Ownable(msg.sender) {
        if (tokenAddress == address(0)) revert ZeroAddress();
        token = IERC20(tokenAddress);
    }
    
    function lockTokens(uint256 amount) external nonReentrant returns (uint256) {
        if (amount == 0) revert ZeroAmount();
        
        bool success = token.transferFrom(msg.sender, address(this), amount);
        if (!success) revert TransferFailed();
        
        lockedBalances[msg.sender] += amount;
        uint256 currentNonce = nonce++;
        
        bytes32 messageHash = keccak256(
            abi.encodePacked(
                msg.sender,
                amount,
                currentNonce,
                block.chainid
            )
        );
        
        emit TokensLocked(msg.sender, amount, currentNonce, messageHash);
        
        return currentNonce;
    }
    
    function unlockTokens(
        address user,
        uint256 amount,
        uint256 unlockNonce
    ) external onlyOwner nonReentrant {
        if (user == address(0)) revert ZeroAddress();
        if (amount == 0) revert ZeroAmount();
        if (processedUnlocks[unlockNonce]) revert InvalidNonce();
        if (lockedBalances[user] < amount) revert InsufficientLockedBalance();
        
        processedUnlocks[unlockNonce] = true;
        lockedBalances[user] -= amount;
        
        bool success = token.transfer(user, amount);
        if (!success) revert TransferFailed();
        
        emit TokensUnlocked(user, amount, unlockNonce);
    }
    
    function getTotalLocked() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}