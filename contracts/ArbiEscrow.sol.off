// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title ArbiEscrow
 * @notice This smart contract allows a client and a provider to safely manage project payments.
 * The client creates a deal, deposits funds, and divides the work into several milestones.
 * When a milestone is completed, the client approves it, and the provider can withdraw the corresponding payment.
 * If a milestone is not approved or the deadline passes, the deal can be cancelled and funds refunded.
 * The contract ensures transparency and prevents cheating between both parties.
 *
 * @dev The contract uses a simple escrow mechanism with milestone-based payouts.
 *      Future versions may include arbitration and DAO-based dispute resolution.
 */
contract ArbiEscrow is Ownable, ReentrancyGuard, Pausable {
    struct Milestone {
        uint id; //Unique identifier of the milestone
        string description; //Short description
        uint amount;
        uint deadline;
        bool approved;
        bool paid;
        bool disputed;
        address provider;
        bool refunded;
    }

    struct Deal {
        uint dealId;
        address client;
        address provider;
        uint totalAmount;
        uint milestoneCount; // total number of milestones allowed
        bool active;
        bool completed;
        uint balance;
    }

    error InvalidProvider();
    error InvalidMilestoneCounter();
    error DealNotExist();
    error DealNotActive();
    error InvalidClientAddress();
    error MilestoneLimitReached();
    error InvalidAmount();
    error InvalidDeadline();
    error MilestoneNotExist();
    error AlreadyApproved();
    error AlreadyPaid();
    error InsufficientBalance();
    error DeadlineNotFinished();

    event MilestoneApproved(
        uint indexed dealId,
        uint indexed milestoneId,
        uint amount,
        address provider
    );
    event DealCreated(
        uint indexed dealId,
        address indexed client,
        address indexed provider,
        uint milestoneCount
    );
    event MilestoneAdded(
        uint indexed dealId,
        uint id,
        uint amount,
        uint deadline
    );
    event MilestoneRefunded(
        uint indexed dealId,
        uint indexed milestoneId,
        uint amount,
        address client
    );

    modifier validDeal(uint _dealId) {
        if (_dealId >= nextDealId) revert DealNotExist();
        if (!deals[_dealId].active) revert DealNotActive();
        _;
    }

    modifier validMilestone(uint _dealId, uint _milestoneId) {
        if (_milestoneId >= milestoneCounter[_dealId])
            revert MilestoneNotExist();
        Milestone storage m = milestones[_dealId][_milestoneId];
        if (m.approved) revert AlreadyApproved();
        if (m.paid) revert AlreadyPaid();
        _;
    }

    mapping(uint => Deal) public deals;
    mapping(uint => mapping(uint => Milestone)) public milestones;
    mapping(uint => uint) public milestoneCounter;

    uint public nextDealId;

    function createDeal(
        address _provider,
        uint _milestoneCount
    ) external payable whenNotPaused {
        if (_provider == address(0)) revert InvalidProvider();
        if (_milestoneCount == 0) revert InvalidMilestoneCounter();

        Deal memory newDeal = Deal({
            dealId: nextDealId,
            client: msg.sender,
            provider: _provider,
            totalAmount: msg.value,
            milestoneCount: _milestoneCount,
            active: true,
            completed: false,
            balance: msg.value
        });
        deals[nextDealId] = newDeal;

        emit DealCreated(nextDealId, msg.sender, _provider, _milestoneCount);
        nextDealId++;
    }
    //@notice Creates a new milestone for an existing deal
    function addMilestone(
        uint _dealId,
        string memory _description,
        uint _amount,
        uint _deadline
    ) external whenNotPaused validDeal(_dealId) {
        if (msg.sender != deals[_dealId].client) revert InvalidClientAddress();
        if (milestoneCounter[_dealId] >= deals[_dealId].milestoneCount)
            revert MilestoneLimitReached();
        if (_amount == 0) revert InvalidAmount();
        if (_deadline <= block.timestamp) revert InvalidDeadline();
        if (_amount > deals[_dealId].balance) revert InsufficientBalance();

        Milestone memory newMilestone = Milestone({
            id: milestoneCounter[_dealId],
            description: _description,
            amount: _amount,
            deadline: _deadline,
            approved: false,
            paid: false,
            disputed: false,
            provider: deals[_dealId].provider,
            refunded: false
        });

        milestones[_dealId][milestoneCounter[_dealId]] = newMilestone;
        milestoneCounter[_dealId]++;

        emit MilestoneAdded(_dealId, newMilestone.id, _amount, _deadline);
    }
    function approveMilestone(
        uint _dealId,
        uint _milestoneId
    )
        external
        whenNotPaused
        nonReentrant
        validDeal(_dealId)
        validMilestone(_dealId, _milestoneId)
    {
        if (msg.sender != deals[_dealId].client) revert InvalidClientAddress();

        Milestone storage m = milestones[_dealId][_milestoneId];
        if (m.deadline <= block.timestamp) revert InvalidDeadline();

        if (deals[_dealId].balance < m.amount) revert InsufficientBalance();

        m.approved = true;
        m.paid = true;
        deals[_dealId].balance -= m.amount;
        (bool ok, ) = payable(m.provider).call{value: m.amount}("");
        require(ok, "PaymentFailed");

        emit MilestoneApproved(_dealId, _milestoneId, m.amount, m.provider);
    }

    function refundMilestone(
        uint _dealId,
        uint _milestoneId
    )
        external
        whenNotPaused
        nonReentrant
        validDeal(_dealId)
        validMilestone(_dealId, _milestoneId)
    {
        if (msg.sender != deals[_dealId].client) revert InvalidClientAddress();
        Milestone storage m = milestones[_dealId][_milestoneId];
        if (m.deadline > block.timestamp) revert DeadlineNotFinished();
        if (deals[_dealId].balance < m.amount) revert InsufficientBalance();

        m.refunded = true;
        m.paid = true;

        deals[_dealId].balance -= m.amount;
        (bool ok, ) = payable(deals[_dealId].client).call{value: m.amount}("");
        require(ok, "RefundFailed");
        emit MilestoneRefunded(
            _dealId,
            _milestoneId,
            m.amount,
            deals[_dealId].client
        );
    }
}
